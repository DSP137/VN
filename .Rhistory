}
origdir <- getwd()
tryCatch({
setwd(thedir) ## put us next to the original Rmarkdown file
out <- match.arg(output)
switch(out,
latex=create_latex(thefile),
html=create_html(thefile),
pdf=create_pdf(thefile),
word=create_word(thefile)
)}, finally=setwd(origdir))
}
##################
rmarkdownTable <- function(df) {
cat(paste(names(df), collapse = "|"))
cat("\n")
cat(paste(rep("-", ncol(df)), collapse = "|"))
cat("\n")
for(i in 1:nrow(df)){
cat(paste(df[i,], collapse = "|"))
cat("\n")
}
invisible(NULL)
}
#require(xtable)
#tab <- xtable(head(iris),digits=2)
#print(tab, type="html")
#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf)
# Chunk 2: toy1
suppressMessages(require(VN)) ||  install.packages("http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz",type="source",method="wget")
suppressMessages(require(igraph))
sim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment
HS <- "full" # or "core"
# parameters for finding seeds
s <- ifelse(sim,4,12) # number of seeds to be used for SGM
h <- ell <- 1 # max walk for finding neighborhoods
# parameters for SGM
R <- 100     # repeat SGM R times to get averaged P matrix
gamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm
mc <- 2
set.seed(1234+mc)
if (sim) {
# generate a pair of correlated graphs
m <- 5  # |J| = junk on G1
n <- 20 # |W| = shared vertices on G1, not including x and S
mp <- 0 # |J'| = junk on G2
d <- 5  # for RDPG, dimension of the random vectors
corr <- 0.5 # for correlated graphs
(nV1 <- 1+s+n+m)
(nV2 <- 1+s+n+mp)
lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG
gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
library(VN)
# Chunk 1: setup
#<link rel="stylesheet" href="http://vis.supstat.com/assets/themes/dinky/css/scianimator.css">
#<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
#<script src="http://vis.supstat.com/assets/themes/dinky/js/jquery.scianimator.min.js"></script>
suppressMessages(require(igraph))
suppressMessages(require(VN))
suppressMessages(require(Matrix))
suppressMessages(require(lattice))
suppressMessages(require(popbio))
suppressMessages(require(ggplot2))
suppressMessages(require(reshape2))
suppressMessages(require(knitr))
suppressMessages(require(printr))
suppressMessages(require(dplyr))
options(digits = 2)
source("~/Dropbox/SGM/nbdmaking/vn.R")
#knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
#dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE,comment="#",
dpi=100,dev=c('png','pdf'))
opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))
opts_knit$set(eval.after = c('fig.cap','fig.scap'))
knit_hooks$set(document = function(x) {                                                                gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                  })
opts_knit$set(animation.fun = hook_scianimator)
#knit_hooks$set(plot = function(x, options) {
#       paste('<figure><img src="',
#             opts_knit$get('base.url'), paste(x, collapse = '.'),
#             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
#             sep = '')
# })
fn = local({
i = 0
function(x) {
i <<- i + 1
#     paste('Figure ', i, ': ', x, sep = '')
paste('', '', x, sep = '')
}
})
rmd.convert <- function(fname, output=c('latex', 'word', 'html', "pdf")){
## Thanks to Robert Musk for helpful additions to make this run better on Windows
require(knitr)
require(tools)
thedir <- file_path_as_absolute(dirname(fname))
thefile <- (basename(fname))
create_latex <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f), ".tex")
mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname),
"tmp-outputfile.md")
system(mess)
cat("The Latex file is", file.path(thedir, newname),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_word <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".docx")
mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The Word (docx) file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_html <- function(f){
knit2html(f)
cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
}
create_pdf <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".pdf")
mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The PDF file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
origdir <- getwd()
tryCatch({
setwd(thedir) ## put us next to the original Rmarkdown file
out <- match.arg(output)
switch(out,
latex=create_latex(thefile),
html=create_html(thefile),
pdf=create_pdf(thefile),
word=create_word(thefile)
)}, finally=setwd(origdir))
}
##################
rmarkdownTable <- function(df) {
cat(paste(names(df), collapse = "|"))
cat("\n")
cat(paste(rep("-", ncol(df)), collapse = "|"))
cat("\n")
for(i in 1:nrow(df)){
cat(paste(df[i,], collapse = "|"))
cat("\n")
}
invisible(NULL)
}
#require(xtable)
#tab <- xtable(head(iris),digits=2)
#print(tab, type="html")
#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf)
# Chunk 2: toy1
suppressMessages(require(VN)) ||  install.packages("http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz",type="source",method="wget")
suppressMessages(require(igraph))
sim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment
HS <- "full" # or "core"
# parameters for finding seeds
s <- ifelse(sim,4,12) # number of seeds to be used for SGM
h <- ell <- 1 # max walk for finding neighborhoods
# parameters for SGM
R <- 100     # repeat SGM R times to get averaged P matrix
gamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm
mc <- 2
set.seed(1234+mc)
if (sim) {
# generate a pair of correlated graphs
m <- 5  # |J| = junk on G1
n <- 20 # |W| = shared vertices on G1, not including x and S
mp <- 0 # |J'| = junk on G2
d <- 5  # for RDPG, dimension of the random vectors
corr <- 0.5 # for correlated graphs
(nV1 <- 1+s+n+m)
(nV2 <- 1+s+n+mp)
lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG
gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
library(VN)
# Chunk 1: setup
#<link rel="stylesheet" href="http://vis.supstat.com/assets/themes/dinky/css/scianimator.css">
#<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
#<script src="http://vis.supstat.com/assets/themes/dinky/js/jquery.scianimator.min.js"></script>
suppressMessages(require(igraph))
suppressMessages(require(VN))
suppressMessages(require(Matrix))
suppressMessages(require(lattice))
suppressMessages(require(popbio))
suppressMessages(require(ggplot2))
suppressMessages(require(reshape2))
suppressMessages(require(knitr))
suppressMessages(require(printr))
suppressMessages(require(dplyr))
options(digits = 2)
source("~/Dropbox/SGM/nbdmaking/vn.R")
#knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
#dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE,comment="#",
dpi=100,dev=c('png','pdf'))
opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))
opts_knit$set(eval.after = c('fig.cap','fig.scap'))
knit_hooks$set(document = function(x) {                                                                gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                  })
opts_knit$set(animation.fun = hook_scianimator)
#knit_hooks$set(plot = function(x, options) {
#       paste('<figure><img src="',
#             opts_knit$get('base.url'), paste(x, collapse = '.'),
#             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
#             sep = '')
# })
fn = local({
i = 0
function(x) {
i <<- i + 1
#     paste('Figure ', i, ': ', x, sep = '')
paste('', '', x, sep = '')
}
})
rmd.convert <- function(fname, output=c('latex', 'word', 'html', "pdf")){
## Thanks to Robert Musk for helpful additions to make this run better on Windows
require(knitr)
require(tools)
thedir <- file_path_as_absolute(dirname(fname))
thefile <- (basename(fname))
create_latex <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f), ".tex")
mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname),
"tmp-outputfile.md")
system(mess)
cat("The Latex file is", file.path(thedir, newname),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_word <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".docx")
mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The Word (docx) file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_html <- function(f){
knit2html(f)
cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
}
create_pdf <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".pdf")
mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The PDF file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
origdir <- getwd()
tryCatch({
setwd(thedir) ## put us next to the original Rmarkdown file
out <- match.arg(output)
switch(out,
latex=create_latex(thefile),
html=create_html(thefile),
pdf=create_pdf(thefile),
word=create_word(thefile)
)}, finally=setwd(origdir))
}
##################
rmarkdownTable <- function(df) {
cat(paste(names(df), collapse = "|"))
cat("\n")
cat(paste(rep("-", ncol(df)), collapse = "|"))
cat("\n")
for(i in 1:nrow(df)){
cat(paste(df[i,], collapse = "|"))
cat("\n")
}
invisible(NULL)
}
#require(xtable)
#tab <- xtable(head(iris),digits=2)
#print(tab, type="html")
#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf)
# Chunk 2: toy1
suppressMessages(require(VN)) ||  install.packages("http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz",type="source",method="wget")
suppressMessages(require(igraph))
sim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment
HS <- "full" # or "core"
# parameters for finding seeds
s <- ifelse(sim,4,12) # number of seeds to be used for SGM
h <- ell <- 1 # max walk for finding neighborhoods
# parameters for SGM
R <- 100     # repeat SGM R times to get averaged P matrix
gamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm
mc <- 2
set.seed(1234+mc)
if (sim) {
# generate a pair of correlated graphs
m <- 5  # |J| = junk on G1
n <- 20 # |W| = shared vertices on G1, not including x and S
mp <- 0 # |J'| = junk on G2
d <- 5  # for RDPG, dimension of the random vectors
corr <- 0.5 # for correlated graphs
(nV1 <- 1+s+n+m)
(nV2 <- 1+s+n+mp)
lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG
gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
library(VN)
require(rmarkdown)
render("vignette/vn.Rmd")
library(VN)
A = matrix(1,9,9)
rownames(A) = sample(9)
A
A[sample(9),sample(9)]
matrix(3:8,10)
cbind(matrix(3:8,10), matrix(2:7, 10))
library(VN)
n=1000
system.time(A <- B <- C <- matrix(0,n,n))
system.time(A <- matrix(0,n,n); B <- matrix(0,n,n); C <- matrix(0,n,n))
library(VN)
require(igraph)
require(Matrix)
g = sample_gnp(100,0.1)
A = g[]
class(A)
B = g[]
#seeds are assumed to be vertices 1:m in both graphs
totv1<-ncol(A)
totv2<-ncol(B)
A[A==0]<- -1
B[B==0]<- -1
diff<-totv1-totv2
for (j in 1:diff){B<-cbind(rbind(B,pad),pad)}
pad=0
totv<-max(totv1,totv2)
m=10
n<-totv-m
A12<-rbind(A[1:m,(m+1):(m+n)])
A21<-cbind(A[(m+1):(m+n),1:m])
B12<-rbind(B[1:m,(m+1):(m+n)])
B21<-cbind(B[(m+1):(m+n),1:m])
A22<-A[(m+1):(m+n),(m+1):(m+n)]
B22<-B[(m+1):(m+n),(m+1):(m+n)]
tol<-1
n
s
S = diag(100)
S[11:100, 11:100] = rsp(90, g=0.5)
require(VN)
S[11:100, 11:100] = rsp(90, g=0.5)
start = S
P<-start
toggle<-1
iter<-0
x<- A21%*%t(B21)
y<- t(A12)%*%B12
iter<-iter+1
z<- A22 %*% P %*% Matrix::t(B22)
class(A22)
class(B22)
class(P)
P <- Matrix(start)
z<- A22 %*% P %*% Matrix::t(B22)
dim(A22)
dim(P)
dim(S)
P = P[1:90,1:90]
z<- A22 %*% P %*% Matrix::t(B22)
w<- Matrix::t(A22) %*% P %*% B22
Grad<-x+y+z+w;
mm=max(abs(Grad))
ind<-clue::solve_LSAP(Grad+matrix(mm,totv-m,totv-m), maximum =TRUE)
mm=max(abs(Grad))
class(mm)
ind<-clue::solve_LSAP(Grad+matrix(mm,totv-m,totv-m), maximum =TRUE)
class(mm)
class(totv)
class(m)
require(clue)
ind<-clue::solve_LSAP(Grad+matrix(mm,totv-m,totv-m), maximum =TRUE)
?solve_LSAP
class(Grad)
ind<-clue::solve_LSAP(matrix(Grad)+matrix(mm,totv-m,totv-m), maximum =TRUE)
ind<-clue::solve_LSAP(as.matrix(Grad)+matrix(mm,totv-m,totv-m), maximum =TRUE)
T<-Diagonal(n)
T<-T[ind,]
class(ind)
str(ind)
ind<-matrix(clue::solve_LSAP(as.matrix(Grad)+matrix(mm,totv-m,totv-m), maximum =TRUE))
T<-Diagonal(n)
T<-T[ind,]
str(ind)
dim(T)
n
T<-diag(n)
T<-T[ind,]
class(T)
wt<-Matrix::t(A22) %*% T %*% B22
class(T)
dim(T)
str(ind)
wt<-Matrix::t(A22) %*% T %*% B22
c<-sum(diag(w%*%Matrix::t(P)))
d<-sum(diag(wt%*%Matrix::t(P)))+sum(diag(w%*%Matrix::t(T)))
e<-sum(diag(wt%*%Matrix::t(T)))
u<-sum(diag(Matrix::t(P)%*%x+Matrix::t(P)%*%y))
v<-sum(diag(Matrix::t(T)%*%x+Matrix::t(T)%*%y))
if( c-d+e==0 && d-2*e+u-v==0){
alpha<-0
}else{
alpha<- -(d-2*e+u-v)/(2*(c-d+e))}
f0<-0
f1<- c-e+u-v
falpha<-(c-d+e)*alpha^2+(d-2*e+u-v)*alpha
if(alpha < tol && alpha > 0 && falpha > f0 && falpha > f1){
P<- alpha*P+(1-alpha)*T
}else if(f0 > f1){
P<-T
}else{
toggle<-0}
library(VN)
