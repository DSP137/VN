gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
# Determine x' amongst the candidates based on the matching probability from SGM
Sx <- NBDS$Sx
x <- NBDS$labelsGxp[length(Sx)+1]
x.ind <- which(NBDS$labelsGx==x)
Cxp <- match(NBDS$Cxp,NBDS$labelsGxp)
prob <- NBDS$P[x.ind,Cxp]
names(prob) <- NBDS$labelsGxp[Cxp]
# Chunk 1: setup
#<link rel="stylesheet" href="http://vis.supstat.com/assets/themes/dinky/css/scianimator.css">
#<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
#<script src="http://vis.supstat.com/assets/themes/dinky/js/jquery.scianimator.min.js"></script>
suppressMessages(require(igraph))
suppressMessages(require(VN))
suppressMessages(require(Matrix))
suppressMessages(require(lattice))
suppressMessages(require(popbio))
suppressMessages(require(ggplot2))
suppressMessages(require(reshape2))
suppressMessages(require(knitr))
suppressMessages(require(printr))
suppressMessages(require(dplyr))
options(digits = 2)
source("~/Dropbox/SGM/nbdmaking/vn.R")
#knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
#dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE,comment="#",
dpi=100,dev=c('png','pdf'))
opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))
opts_knit$set(eval.after = c('fig.cap','fig.scap'))
knit_hooks$set(document = function(x) {                                                                gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                  })
opts_knit$set(animation.fun = hook_scianimator)
#knit_hooks$set(plot = function(x, options) {
#       paste('<figure><img src="',
#             opts_knit$get('base.url'), paste(x, collapse = '.'),
#             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
#             sep = '')
# })
fn = local({
i = 0
function(x) {
i <<- i + 1
#     paste('Figure ', i, ': ', x, sep = '')
paste('', '', x, sep = '')
}
})
rmd.convert <- function(fname, output=c('latex', 'word', 'html', "pdf")){
## Thanks to Robert Musk for helpful additions to make this run better on Windows
require(knitr)
require(tools)
thedir <- file_path_as_absolute(dirname(fname))
thefile <- (basename(fname))
create_latex <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f), ".tex")
mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname),
"tmp-outputfile.md")
system(mess)
cat("The Latex file is", file.path(thedir, newname),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_word <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".docx")
mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The Word (docx) file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_html <- function(f){
knit2html(f)
cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
}
create_pdf <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".pdf")
mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The PDF file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
origdir <- getwd()
tryCatch({
setwd(thedir) ## put us next to the original Rmarkdown file
out <- match.arg(output)
switch(out,
latex=create_latex(thefile),
html=create_html(thefile),
pdf=create_pdf(thefile),
word=create_word(thefile)
)}, finally=setwd(origdir))
}
##################
rmarkdownTable <- function(df) {
cat(paste(names(df), collapse = "|"))
cat("\n")
cat(paste(rep("-", ncol(df)), collapse = "|"))
cat("\n")
for(i in 1:nrow(df)){
cat(paste(df[i,], collapse = "|"))
cat("\n")
}
invisible(NULL)
}
#require(xtable)
#tab <- xtable(head(iris),digits=2)
#print(tab, type="html")
#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf)
# Chunk 2: toy1
suppressMessages(require(VN)) ||  install.packages("http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz",type="source",method="wget")
suppressMessages(require(igraph))
sim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment
HS <- "full" # or "core"
# parameters for finding seeds
s <- ifelse(sim,4,12) # number of seeds to be used for SGM
h <- ell <- 1 # max walk for finding neighborhoods
# parameters for SGM
R <- 100     # repeat SGM R times to get averaged P matrix
gamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm
mc <- 2
set.seed(1234+mc)
if (sim) {
# generate a pair of correlated graphs
m <- 5  # |J| = junk on G1
n <- 20 # |W| = shared vertices on G1, not including x and S
mp <- 0 # |J'| = junk on G2
d <- 5  # for RDPG, dimension of the random vectors
corr <- 0.5 # for correlated graphs
(nV1 <- 1+s+n+m)
(nV2 <- 1+s+n+mp)
lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG
gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
library(VN)
# Chunk 1: setup
#<link rel="stylesheet" href="http://vis.supstat.com/assets/themes/dinky/css/scianimator.css">
#<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
#<script src="http://vis.supstat.com/assets/themes/dinky/js/jquery.scianimator.min.js"></script>
suppressMessages(require(igraph))
suppressMessages(require(VN))
suppressMessages(require(Matrix))
suppressMessages(require(lattice))
suppressMessages(require(popbio))
suppressMessages(require(ggplot2))
suppressMessages(require(reshape2))
suppressMessages(require(knitr))
suppressMessages(require(printr))
suppressMessages(require(dplyr))
options(digits = 2)
source("~/Dropbox/SGM/nbdmaking/vn.R")
#knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
#dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE,comment="#",
dpi=100,dev=c('png','pdf'))
opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))
opts_knit$set(eval.after = c('fig.cap','fig.scap'))
knit_hooks$set(document = function(x) {                                                                gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                  })
opts_knit$set(animation.fun = hook_scianimator)
#knit_hooks$set(plot = function(x, options) {
#       paste('<figure><img src="',
#             opts_knit$get('base.url'), paste(x, collapse = '.'),
#             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
#             sep = '')
# })
fn = local({
i = 0
function(x) {
i <<- i + 1
#     paste('Figure ', i, ': ', x, sep = '')
paste('', '', x, sep = '')
}
})
rmd.convert <- function(fname, output=c('latex', 'word', 'html', "pdf")){
## Thanks to Robert Musk for helpful additions to make this run better on Windows
require(knitr)
require(tools)
thedir <- file_path_as_absolute(dirname(fname))
thefile <- (basename(fname))
create_latex <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f), ".tex")
mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname),
"tmp-outputfile.md")
system(mess)
cat("The Latex file is", file.path(thedir, newname),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_word <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".docx")
mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The Word (docx) file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_html <- function(f){
knit2html(f)
cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
}
create_pdf <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".pdf")
mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The PDF file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
origdir <- getwd()
tryCatch({
setwd(thedir) ## put us next to the original Rmarkdown file
out <- match.arg(output)
switch(out,
latex=create_latex(thefile),
html=create_html(thefile),
pdf=create_pdf(thefile),
word=create_word(thefile)
)}, finally=setwd(origdir))
}
##################
rmarkdownTable <- function(df) {
cat(paste(names(df), collapse = "|"))
cat("\n")
cat(paste(rep("-", ncol(df)), collapse = "|"))
cat("\n")
for(i in 1:nrow(df)){
cat(paste(df[i,], collapse = "|"))
cat("\n")
}
invisible(NULL)
}
#require(xtable)
#tab <- xtable(head(iris),digits=2)
#print(tab, type="html")
#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf)
# Chunk 2: toy1
suppressMessages(require(VN)) ||  install.packages("http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz",type="source",method="wget")
suppressMessages(require(igraph))
sim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment
HS <- "full" # or "core"
# parameters for finding seeds
s <- ifelse(sim,4,12) # number of seeds to be used for SGM
h <- ell <- 1 # max walk for finding neighborhoods
# parameters for SGM
R <- 100     # repeat SGM R times to get averaged P matrix
gamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm
mc <- 2
set.seed(1234+mc)
if (sim) {
# generate a pair of correlated graphs
m <- 5  # |J| = junk on G1
n <- 20 # |W| = shared vertices on G1, not including x and S
mp <- 0 # |J'| = junk on G2
d <- 5  # for RDPG, dimension of the random vectors
corr <- 0.5 # for correlated graphs
(nV1 <- 1+s+n+m)
(nV2 <- 1+s+n+mp)
lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG
gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
library(VN)
# Chunk 1: setup
#<link rel="stylesheet" href="http://vis.supstat.com/assets/themes/dinky/css/scianimator.css">
#<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
#<script src="http://vis.supstat.com/assets/themes/dinky/js/jquery.scianimator.min.js"></script>
suppressMessages(require(igraph))
suppressMessages(require(VN))
suppressMessages(require(Matrix))
suppressMessages(require(lattice))
suppressMessages(require(popbio))
suppressMessages(require(ggplot2))
suppressMessages(require(reshape2))
suppressMessages(require(knitr))
suppressMessages(require(printr))
suppressMessages(require(dplyr))
options(digits = 2)
source("~/Dropbox/SGM/nbdmaking/vn.R")
#knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
#dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE,comment="#",
dpi=100,dev=c('png','pdf'))
opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))
opts_knit$set(eval.after = c('fig.cap','fig.scap'))
knit_hooks$set(document = function(x) {                                                                gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                  })
opts_knit$set(animation.fun = hook_scianimator)
#knit_hooks$set(plot = function(x, options) {
#       paste('<figure><img src="',
#             opts_knit$get('base.url'), paste(x, collapse = '.'),
#             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
#             sep = '')
# })
fn = local({
i = 0
function(x) {
i <<- i + 1
#     paste('Figure ', i, ': ', x, sep = '')
paste('', '', x, sep = '')
}
})
rmd.convert <- function(fname, output=c('latex', 'word', 'html', "pdf")){
## Thanks to Robert Musk for helpful additions to make this run better on Windows
require(knitr)
require(tools)
thedir <- file_path_as_absolute(dirname(fname))
thefile <- (basename(fname))
create_latex <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f), ".tex")
mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname),
"tmp-outputfile.md")
system(mess)
cat("The Latex file is", file.path(thedir, newname),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_word <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".docx")
mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The Word (docx) file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
create_html <- function(f){
knit2html(f)
cat("The main HTML file is", file.path(thedir, paste0(file_path_sans_ext(f), ".html")),
"\nIf transporting do not forget to include the folder", file.path(thedir, "figure"), "\n")
}
create_pdf <- function(f){
knit(f, 'tmp-outputfile.md');
newname <- paste0(file_path_sans_ext(f),".pdf")
mess <- paste('pandoc -f markdown -o', shQuote(newname), "tmp-outputfile.md")
system(mess)
cat("The PDF file is", file.path(thedir, newname), "\n")
mess <- paste('rm tmp-outputfile.md')
system(mess)
}
origdir <- getwd()
tryCatch({
setwd(thedir) ## put us next to the original Rmarkdown file
out <- match.arg(output)
switch(out,
latex=create_latex(thefile),
html=create_html(thefile),
pdf=create_pdf(thefile),
word=create_word(thefile)
)}, finally=setwd(origdir))
}
##################
rmarkdownTable <- function(df) {
cat(paste(names(df), collapse = "|"))
cat("\n")
cat(paste(rep("-", ncol(df)), collapse = "|"))
cat("\n")
for(i in 1:nrow(df)){
cat(paste(df[i,], collapse = "|"))
cat("\n")
}
invisible(NULL)
}
#require(xtable)
#tab <- xtable(head(iris),digits=2)
#print(tab, type="html")
#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf)
# Chunk 2: toy1
suppressMessages(require(VN)) ||  install.packages("http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz",type="source",method="wget")
suppressMessages(require(igraph))
sim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment
HS <- "full" # or "core"
# parameters for finding seeds
s <- ifelse(sim,4,12) # number of seeds to be used for SGM
h <- ell <- 1 # max walk for finding neighborhoods
# parameters for SGM
R <- 100     # repeat SGM R times to get averaged P matrix
gamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm
mc <- 2
set.seed(1234+mc)
if (sim) {
# generate a pair of correlated graphs
m <- 5  # |J| = junk on G1
n <- 20 # |W| = shared vertices on G1, not including x and S
mp <- 0 # |J'| = junk on G2
d <- 5  # for RDPG, dimension of the random vectors
corr <- 0.5 # for correlated graphs
(nV1 <- 1+s+n+m)
(nV2 <- 1+s+n+mp)
lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG
gg <- rdpg.sample.correlated(t(lpvs),corr)
g1 <- gg[[1]];
g2 <- gg[[2]];
g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|
W <- intersect(V(g1),V(g2)) # shared vertices
} else {
data("HSgraphs")
if (HS == "full") {
# rearrange the vertices so that the to-be-selected seeds are valid
perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))
perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))
g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)
g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)
W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices
} else { # core graphs
g1 <- HSfbgraphcore # (82,513)
g2 <- HSfrgraphcore # (82,214)
W <- intersect(V(g1),V(g2)) # shared vertices
}
# Chunk 3: seed
# Randomly select x and S from W, the shared vertices
(x <- sample(W,1))
W <- setdiff(W,x) # exclude x from W
maxseed <- min(length(W),s)
(S <- sort(sample(W,maxseed)))
# Chunk 4: sgm
# Determine Sx and C'x, then do SGM
NBDS <- vnsgm(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)
str(NBDS)
library(VN)
require(rmarkdown)
render("vignette/vn.Rmd")
