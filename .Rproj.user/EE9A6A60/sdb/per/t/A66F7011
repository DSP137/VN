{
    "collab_server" : "",
    "contents" : "#' Finds the seeds in an \\eqn{h}-hop induced nbd of \\eqn{G_1} around the\n#' VOI, x,\n#'                      that is, finds induced subgraph generated by\n#'                      vertices that are within a path of length \\eqn{h}\n#'                      the VOI,\n#' and then finds an \\eqn{ell}-hop induced nbd of \\eqn{G_1} around the\n#' seeds within the \\eqn{h}-hop nbd of x, and an \\eqn{ell}-hop induced\n#' nbd of \\eqn{G_2} around the corresponding seeds.\n#' Then, matches these induced subgraphs via \\code{multiStart}.\n#'\n#'\n#' @param x vector of indices for vertices of interest (voi) in \\eqn{G_1}\n#' @param S vector of a set of seeds\n#' @param g1 \\eqn{G_1} in \\code{igraph} object where voi is known\n#' @param g2 \\eqn{G_2} in \\code{igraph}\n#' @param h \\eqn{h}-hop for distance from voi to other vertices\n#'          to create \\eqn{h}-hop induced subgraph of \\eqn{G_1}\n#' @param ell \\eqn{ell}-hop for distance from seeds to other vertices\n#'          to create \\eqn{ell}-hop induced subgraph of \\eqn{G_1}\n#' @param R number of restarts for \\code{multiStart}\n#' @param g gamma to be used with \\code{multiStart}, max tolerance for alpha, how far away from the barycenter user is willing to go for\n#' the initialization of \\code{sgm} on any given iteration\n#' @param pad a scalar value for padding for sgm\n#' @param sim boolean: default TRUE (yes, this is a simulation) --\n#' assumes x = x' (i.e. indices for VOI in \\eqn{G_1} are the same as\n#' the indices for the corresponding matches in \\eqn{G_2})\n#' @param verb verbose outputs\n#' @param plotF boolean to plot the probability matrix\n#'\n#' @return \\code{seed} \\code{s} seeds\n#' @return \\code{cand} labels for the candidates in \\eqn{G_2}\n#' @return \\code{ind1} labels for the vertices in \\eqn{G_1}\n#' @return \\code{ind2} labels for the vertices in \\eqn{G_2}\n#' @return \\code{P} matrix \\eqn{P(i,j)} is the proportion of times that vertex \\eqn{j} in\n#' the induced subgraph of \\eqn{G_2} was mapped to vertex \\eqn{i} in the induced subgraph of \\eqn{G_1}.\n#' Then the \\eqn{i-th} and \\eqn{j-th} elements of the labels vector tells you which vertices these actually were\n#' in \\eqn{G_1} and \\eqn{G_2}, respectively.\n#'\n#' @author Youngser Park <youngser@jhu.edu>\n#' @export\n\nlocalnbd <- function(x,S,g1,g2,h,ell,R,g,pad=0,sim=TRUE,verb=FALSE,plotF=FALSE) {\n\n### note: may need to fix later: assumes dimension of A is larger ###\n### also assumes that B aligns with first nrow(B) vertices of A ###\n#g1 <- graph_from_adjacency_matrix(A,mode=\"undirected\")\n#g2 <- graph_from_adjacency_matrix(B,mode=\"undirected\")\n\n# Note, V = {x,S,W,J}\n# sanity check\n#    W <- intersect(V(g1),V(g2))\n#    J1 <- setdiff(V(g1),W); m1 <- length(J1)\n#    J2 <- setdiff(V(g2),W); m2 <- length(J2)\n#    W <- setdiff(W,x) # exclude x from W\n#    W <- setdiff(W,S)\n    s <- length(S)\n#    stopifnot(1+s+length(W)+m1 == vcount(g1))\n#    stopifnot(1+s+length(W)+m2 == vcount(g2))\n    # end of sanity check\n\n    # make h-hop nbhd for x in A\n    Nh <- unlist(ego(g1,h,nodes=x,mindist=1)) # mindist=0: close, 1: open\n\n    # Find S_x = all seeds in Nh, == Sx2\n    Sx1 <- Sx2 <- NULL\n    Sx1 <- sort(intersect(Nh,S)); sx <- length(Sx1)\n    Sx2 <- sort(intersect(V(g2),Sx1)); sx2 <- length(Sx2)\n#    stopifnot(identical(Sx1,Sx2))\n    case <- ifelse((sx2>0), \"possible\", \"impossible1\")\n\n    if (case == \"possible\") {\n        # Find Candidates\n        Cx2 <- sort(unique(unlist(ego(g2,ell,nodes=Sx2,mindist=1)))) # mindist=0: close, 1: open\n        # make sure seeds aren't included (open: mindist=1)\n        Cx2 <- setdiff(Cx2,Sx2)\n\n        if(sim){\n            case <- ifelse((x %in% Cx2), \"possible\", \"impossible2\")\n        }\n\n        # Find induced subgraph from Sx1 & Sx2\n        if (any(case==\"possible\")) {\n            Nx1 <- sort(unique(unlist(ego(g1,ell,nodes=Sx1,mindist=0)))) # mindist=0: close, 1: open\n            Nx2 <- sort(unique(unlist(ego(g2,ell,nodes=Sx2,mindist=0)))) # mindist=0: close, 1: open\n    #subg1 <- induced_subgraph(g1,Nx1); #summary(subg1)\n    #subg2 <- induced_subgraph(g2,Nx2); #summary(subg2)\n#        stopifnot(x %in% Nx1)\n\n            if(sim){\n                wxp <- which(case==\"possible\")\n                xp <- x[wxp]\n                (ind1 <- c(Sx1,x,setdiff(Nx1,c(Sx1,xp)))) # is this x or xp??\n                (ind2 <- c(Sx2,xp,setdiff(Nx2,c(Sx2,xp))))\n            }else{\n                (ind1 <- c(Sx1,x,setdiff(Nx1,c(Sx1,x))))\n                (ind2 <- c(Sx2,setdiff(Nx2,Sx2)))\n            }\n\n            if (verb) {\n                cat(\"seed = \", Sx1, \", matching \", ind1, \" and \", ind2, \"\\n\")\n            }\n\n            iter <- 20 # The number of iterations for the Frank-Wolfe algorithm\n            A <- as.matrix(g1[][ind1,ind1])\n            B <- as.matrix(g2[][ind2,ind2])\n            P <- multiStart(A,B,R,length(Sx1),g,pad=pad,iter)\n            #seeds are assumed to be vertices 1:s in both graphs\n            if (plotF) {\n                plotP(P,ind2,ind1,Sx1)\n            }\n        } else {\n            ind1 <- ind2 <- P <- NULL\n        }\n    } else {\n        ind1 <- ind2 <- P <- Cx2 <- NULL\n    }\n\n    return(list(case=case, x=x, S=S, Sx=Sx1, Sxp=Sx2, Cxp=Cx2, labelsGx=ind1, labelsGxp=ind2, P=P))\n}\n\nlocalnbd2 <- function(x,S,g1,g2,h,R,g,verb=FALSE){\n\n    s <- length(S)\n    s1 <- S[1]\n\n    # make h-hop nbhd for x in A\n    Nh1 <- unlist(ego(g1,h,nodes=s1,mindist=1)) # mindist=0: close, 1: open\n    Nh2 <- unlist(ego(g2,h,nodes=s1,mindist=1)) # mindist=0: close, 1: open\n    case <- ifelse((x %in% Nh2 & s>0) , \"possible\", \"impossible\")\n\n    # Find S_x = all seeds in Nh, == Sx2\n    Sx1 <- S; sx <- length(Sx1)\n    Sx2 <- S; sx2 <- length(Sx2)\n\n    if (case==\"possible\") {\n        # Find Candidates\n        Cx1 <- setdiff(Nh1,c(Sx1,x))\n        Cx2 <- setdiff(Nh2,c(Sx2,x))\n\n        (ind1 <- c(Sx1,x,Cx1))\n        (ind2 <- c(Sx2,x,Cx2))\n\n        if (verb) {\n            cat(\"seed = \", Sx1, \", matching \", ind1, \" and \", ind2, \"\\n\")\n        }\n\n        iter <- 20 # The number of iterations for the Frank-Wolfe algorithm\n        A <- as.matrix(g1[][ind1,ind1])\n        B <- as.matrix(g2[][ind2,ind2])\n        matchnbdD <- multiStart(A,B,R,length(Sx1),g,iter)\n        #seeds are assumed to be vertices 1:s in both graphs\n    } else {\n        Cx2 <- ind1 <- ind2 <- matchnbdD <- NULL\n    }\n\n    return(list(case=case, S=S, Sx=Sx1, Cxp=Cx2, labelsGx=ind1, labelsGxp=ind2, matchnbdD=matchnbdD))\n}\n\nplotP <- function(P,labelsGxp,labelsGx,Sx)\n{\n    require(Matrix)\n    require(lattice)\n\n    p <- image(Matrix(P[,1:length(labelsGxp)]),xlab=expression(V(G*minute[x])), ylab=expression(V(G[x])),\n          scales=list(\n              #          tck=c(1,0),\n              #          alternating=c(3),\n              x=list(\n                  at=1:length(labelsGxp),\n                  labels=as.character(labelsGxp)\n              ),\n              y=list(\n                  at=1:length(labelsGx),\n                  labels=as.character(labelsGx)\n              )\n          ))\n    print(p)\n    trellis.focus(\"panel\", 1, 1, highlight=FALSE)\n    s <- length(Sx)\n    lrect((s+0.5),(s+0.5),length(labelsGxp)+0.5,(s+1)+0.5,col=\"red\",alpha=0.2)\n    trellis.unfocus()\n}\n",
    "created" : 1497361875665.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2599477426",
    "id" : "A66F7011",
    "lastKnownWriteTime" : 1492903692,
    "last_content_update" : 1492903692,
    "path" : "~/Dropbox/SGM/VN/R/localnbd.r",
    "project_path" : "R/localnbd.r",
    "properties" : {
        "docOutlineVisible" : "0"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}