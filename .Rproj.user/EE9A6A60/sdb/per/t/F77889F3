{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Vertex Nomination via Seeded Graph Matching\"\nauthor: \"Carey E. Priebe, Youngser Park, Heather Patsolic, Vince Lyzinski <br> Johns Hopkins University\"\ndate: '`r Sys.Date()`'\noutput:\n  html_document:\n    code_folding: show\n    css: ~/RFolder/pandoc.css\n    fig.path: ~/Dropbox/SGM/nbdmaking/figure/\n    fig_caption: yes\n    fig_height: 6\n    fig_width: 6\n    highlight: pygments\n    keep_md: yes\n    number_sections: yes\n    theme: cerulean\n    toc: yes\n    toc_depth: 3\n    toc_float: no\n  pdf_document:\n    fig_caption: yes\n    keep_tex: yes\n    number_sections: yes\n---\n\n<style type=\"text/css\">\n.table {\n    width: 40%;\n}\n</style>\n\n```{r setup,include=FALSE,results='asis'}\n#<link rel=\"stylesheet\" href=\"http://vis.supstat.com/assets/themes/dinky/css/scianimator.css\">\n#<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js\"></script>\n#<script src=\"http://vis.supstat.com/assets/themes/dinky/js/jquery.scianimator.min.js\"></script>\n\nsuppressMessages(require(igraph))\nsuppressMessages(require(VN))\nsuppressMessages(require(Matrix))\nsuppressMessages(require(lattice))\nsuppressMessages(require(popbio))\nsuppressMessages(require(ggplot2))\nsuppressMessages(require(reshape2))\nsuppressMessages(require(knitr))\nsuppressMessages(require(printr))\nsuppressMessages(require(dplyr))\n\noptions(digits = 2)\n\nsource(\"~/Dropbox/SGM/nbdmaking/vn.R\")\n\n#knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)\n#dep_auto() # figure out dependencies automatically\nopts_chunk$set(cache=FALSE,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE,comment=\"#\",\n               dpi=100,dev=c('png','pdf'))\n\nopts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))     \n\nopts_knit$set(eval.after = c('fig.cap','fig.scap'))                                                                            \nknit_hooks$set(document = function(x) {                                                                gsub('(\\\\\\\\end\\\\{knitrout\\\\}[\\n]+)', '\\\\1\\\\\\\\noindent ', x)                                  })\nopts_knit$set(animation.fun = hook_scianimator)\n\n#knit_hooks$set(plot = function(x, options) {\n#       paste('<figure><img src=\"',\n#             opts_knit$get('base.url'), paste(x, collapse = '.'),\n#             '\"><figcaption>', options$fig.cap, '</figcaption></figure>',\n#             sep = '')\n# })\n\n fn = local({\n   i = 0\n   function(x) {\n     i <<- i + 1\n#     paste('Figure ', i, ': ', x, sep = '')\n     paste('', '', x, sep = '')\n   }\n })\n\nrmd.convert <- function(fname, output=c('latex', 'word', 'html', \"pdf\")){\n  ## Thanks to Robert Musk for helpful additions to make this run better on Windows\n\n  require(knitr)\n  require(tools)\n  \n  thedir <- file_path_as_absolute(dirname(fname))\n  thefile <- (basename(fname)) \n  \n  create_latex <- function(f){\n    knit(f, 'tmp-outputfile.md'); \n    newname <- paste0(file_path_sans_ext(f), \".tex\")\n    mess <- paste('pandoc -f markdown -t latex -s -o', shQuote(newname), \n                  \"tmp-outputfile.md\")\n    system(mess)\n    cat(\"The Latex file is\", file.path(thedir, newname), \n        \"\\nIf transporting do not forget to include the folder\", file.path(thedir, \"figure\"), \"\\n\")\n    mess <- paste('rm tmp-outputfile.md')\n    system(mess)\n  }\n\n  create_word <- function(f){\n    knit(f, 'tmp-outputfile.md');\n    newname <- paste0(file_path_sans_ext(f),\".docx\")\n    mess <- paste('pandoc -f markdown -t docx -o', shQuote(newname), \"tmp-outputfile.md\")\n    system(mess)\n    cat(\"The Word (docx) file is\", file.path(thedir, newname), \"\\n\")\n    mess <- paste('rm tmp-outputfile.md')\n    system(mess)\n  }\n  \n  create_html <- function(f){\n    knit2html(f)\n    cat(\"The main HTML file is\", file.path(thedir, paste0(file_path_sans_ext(f), \".html\")), \n        \"\\nIf transporting do not forget to include the folder\", file.path(thedir, \"figure\"), \"\\n\")\n  }\n\n  create_pdf <- function(f){\n    knit(f, 'tmp-outputfile.md');\n    newname <- paste0(file_path_sans_ext(f),\".pdf\")\n    mess <- paste('pandoc -f markdown -o', shQuote(newname), \"tmp-outputfile.md\")\n    system(mess)\n    cat(\"The PDF file is\", file.path(thedir, newname), \"\\n\")\n    mess <- paste('rm tmp-outputfile.md')\n    system(mess)\n  }\n\n  origdir <- getwd()  \n  tryCatch({\n    setwd(thedir) ## put us next to the original Rmarkdown file\n    out <- match.arg(output)\n    switch(out,\n      latex=create_latex(thefile),\n      html=create_html(thefile),\n      pdf=create_pdf(thefile),\n      word=create_word(thefile)\n    )}, finally=setwd(origdir))\n  \n}\n\n##################\nrmarkdownTable <- function(df) {\n    cat(paste(names(df), collapse = \"|\"))\n    cat(\"\\n\")\n    cat(paste(rep(\"-\", ncol(df)), collapse = \"|\"))\n    cat(\"\\n\")\n\n    for(i in 1:nrow(df)){\n        cat(paste(df[i,], collapse = \"|\"))\n        cat(\"\\n\")\n    }\n    invisible(NULL)\n}\n\n\n#require(xtable)\n#tab <- xtable(head(iris),digits=2)\n#print(tab, type=\"html\")\n\n#(http://www.cis.jhu.edu/~parky/XDATA/SGM/27SGM_for_VN_20160518.pdf) \n\n```\n# Background\n\n* A short summary of the methodology is  [here](http://www.cis.jhu.edu/~parky/XDATA/SGM/vnsgm_summary.pdf).\n* The latest draft of our paper is ~~here~~ (unlinked for the future newer version).\n* The poster for [SIAMNS16](http://www.siam.org/meetings/ns16/) is [here](http://www.cis.jhu.edu/~parky/XDATA/SGM/SIAM-NS16-VNSGM.pdf).\n* The slide set for [JSM2016](https://www.amstat.org/meetings/jsm/2016/) is [here](http://www.cis.jhu.edu/~parky/XDATA/SGM/JSM2016-VNLNM.pdf).\n\n<figure>\n<img src=\"vnsgm.jpg\" width=\"700px\" />\n</figure>\n\nHere we describe our approach to both the simulations and the illustrative experiments, which allows the same code to be used to address a real problem in anger (when we don’t know any truth except the VOI $x$ and some seeds $S \\leftrightarrow S'$).  \nIf it’s a simulation or illustrative experiment: (1) generate $G$ and $G'$ with some shared vertices and some unshared vertices, or start with real data $G$ and $G'$ with a collection of known shared vertices and some unknown or unshared vertices, and (2) randomly pick VOI $x$ and some number of seeds $S\\leftrightarrow S'$ from amongst the shared vertices; then embark on our procedure described below. If it’s a real problem, with given VOI $x$ and some seeds $S \\leftrightarrow S'$, then embark immediately on our procedure described below.\n\n# Toy Example\n\n> **input**: $G$, $G'$, seedset $S\\leftrightarrow S'$ (pairs of vertices one in $G$ & one in $G'$), $x$ (vertex of interest in $G$), $h \\leq \\ell$.  \n> **output**: list of (`candidate`,`probability`) where   \n    - `candidates` are non-seed vertices in $G'$ and    \n    - `probability` is for nomination as match for $x$.  \n\n\nThis toy example follows these steps:\n\n1. build a pair of $\\rho$-correlated RDPG random graphs, $G(V,E)$ & $G'(V',E')$, where $|V|=|V'|=30$\n2. remove the last $5$ vertices from $G'$ to make $|V(G)| \\geq |V(G')|$\n3. randomly pick VOI $x$ and $s$ seeds from amongst the shared vertices\n4. find $S_x$, all seeds in $N_h(x)$ in $G$, and matching $S'_x$ in $G'$, let $s_x = |S_x| = |S'_x|$, if $s_x=0$, then \"`impossible1`\"\n5. let $C'_x = N_\\ell(S'_x)$ be the _candidates_ for the match $x'$ to the VOI $x$ for $\\ell\\geq h$, if $x' \\notin C'_x$, then \"`impossible2`\"\n6. find $G_x = \\Omega(N_\\ell[S_x])$ and $G'_x = \\Omega(N_\\ell[S'_x])$ \n7. do `SGM`$(G_x, G'_x, S_x \\leftrightarrow S'_x)$ which returns $P=|V_x| \\times |V'_x|$ matching probability matrix\n8. find $\\hat{x}' = \\arg\\max_{v \\in {C'_x}} P[x,v]$\n\nSo now we do `SGM`$(G_x,G'_x,S_x \\leftrightarrow S'_x)$ -- a smaller SGM problem. (NB: original is this with $h=\\infty$.)  \n\nNB: Steps 4-8 are the same for simulation, illustrative experiment, and real application.  \n\n\n```{r toy1}\nsuppressMessages(require(VN)) ||  install.packages(\"http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.1.0.tar.gz\",type=\"source\",method=\"wget\")\n\nsuppressMessages(require(igraph))\n\nsim <- TRUE # if TRUE, run simulation, otherwise do the HS experiment\nHS <- \"full\" # or \"core\"\n\n# parameters for finding seeds\ns <- ifelse(sim,4,12) # number of seeds to be used for SGM\nh <- ell <- 1 # max walk for finding neighborhoods\n\n# parameters for SGM\nR <- 100     # repeat SGM R times to get averaged P matrix\ngamma <- 0.1 # number of iterations for the Frank-Wolfe algorithm\n\nmc <- 2\nset.seed(1234+mc)\n\nif (sim) {\n    # generate a pair of correlated graphs\n    m <- 5  # |J| = junk on G1\n    n <- 20 # |W| = shared vertices on G1, not including x and S\n    mp <- 0 # |J'| = junk on G2 \n    d <- 5  # for RDPG, dimension of the random vectors\n    corr <- 0.5 # for correlated graphs\n\n    (nV1 <- 1+s+n+m)\n    (nV2 <- 1+s+n+mp)\n    lpvs <- sample_sphere_surface(dim=d, n=nV1)/1.5 # random vectors for RDPG\n    gg <- rdpg.sample.correlated(t(lpvs),corr)\n    g1 <- gg[[1]]; \n    g2 <- gg[[2]]; \n    g2 <- delete_vertices(g2,v=(nV2+1):nV1); # remove m vertices from G' to make |V(G)| != |V(G')|\n    W <- intersect(V(g1),V(g2)) # shared vertices\n} else {\n    data(\"HSgraphs\")\n    if (HS == \"full\") {\n        # rearrange the vertices so that the to-be-selected seeds are valid\n        perm.fb <- c(coremap[,1],setdiff(1:vcount(HSfbgraphfull),coremap[,1]))\n        perm.fr <- c(coremap[,2],setdiff(1:vcount(HSfriendsgraphfull),coremap[,2]))\n        g1 <- permute.vertices(HSfbgraphfull,perm.fb) # (156,1437)\n        g2 <- permute.vertices(HSfriendsgraphfull,perm.fr) # (134,668)\n        W <- 1:nrow(coremap) # seeds should be selected from the shared (core) vertices\n    } else { # core graphs\n        g1 <- HSfbgraphcore # (82,513)\n        g2 <- HSfrgraphcore # (82,214)\n        W <- intersect(V(g1),V(g2)) # shared vertices\n    }\n}\n```\n\n```{r seed}\n# Randomly select x and S from W, the shared vertices\n(x <- sample(W,1))\nW <- setdiff(W,x) # exclude x from W\nmaxseed <- min(length(W),s)\n(S <- sort(sample(W,maxseed))) \n```\n\n```{r sgm,echo=TRUE,eval=TRUE, w=5,h=5,fig.cap=paste(\"A submatrix of a probability matrix output from SGM. Rows correspond to vertices in $V(G_x)$ and columns correspond to vertices in $V(G\\'_x)$. The first \",length(NBDS$Sx),\" rows and columns correspond to the seeds $(S_x,S\\'_x)$, The next row is $x$. The shaded area (in pink) depicts matching probabilities of vertices in $C\\'_x$ against $x$ in $V(G_x)$. The vertices with the highest probability among these _candidates_ is nominated as our best guess for $x\\'$.\")}\n# Determine Sx and C'x, then do SGM\nNBDS <- localnbd(x,S,g1,g2,h,ell,R,gamma,plotF=TRUE)\nstr(NBDS)\n```\n```{r probmat,echo=FALSE,eval=FALSE, w=5,h=5,fig.cap=paste(\"A probability matrix from `SGM`. Rows are $V(G)$ and columns are $V(G\\')$. The first \",length(NBDS$Sx),\" rows and columns are seeds ($S_x$), The next row is $x$. The shaded area (in pink) depicts matching probabilities of $G\\'$ vertices against $x$ in $G$. The one with the highest probability among these _candidates_ becomes the potential $x\\'$ we seek.\")}\nimage(Matrix(NBDS$P[,1:length(NBDS$labelsGxp)]),xlab=expression(G*minute[x]), ylab=expression(G[x]),\n      scales=list(\n#          tck=c(1,0),\n#          alternating=c(3),\n          x=list(\n              at=1:length(NBDS$labelsGxp),\n              labels=as.character(NBDS$labelsGxp)\n          ),\n          y=list(\n              at=1:length(NBDS$labelsGx),\n              labels=as.character(NBDS$labelsGx)\n          )\n      ))\ntrellis.focus(\"panel\", 1, 1, highlight=FALSE)\ns <- length(NBDS$Sx)\nlrect((s+0.5),(s+0.5),length(NBDS$labelsGxp)+0.5,(s+1)+0.5,col=\"red\",alpha=0.2)\ntrellis.unfocus()\n```\n```{r probmat2,echo=FALSE,eval=FALSE,fig.cap=fn('A probability matrix of SGM. Rows are G vertices and columns are G\" vertices. The first $s_x=2$ rows and columns are seeds ($S_x$), The next row is $x$. The shaded area depicts averaged matching probabilities of G2 vertices against $x$. ')}\ndat <- NBDS$P\ndat <- dat[,1:length(NBDS$ind2)]\nrownames(dat) <- NBDS$ind1\ncolnames(dat) <- NBDS$ind2\nimage2(dat,text.cex=.8,log=TRUE,border=\"gray70\",box.offset=0.1,srt=0,labels=c(2,3),mar=c(1,3,3,1))\nrect(s+1,nrow(dat)-s,ncol(dat)+1,nrow(dat)-s+1,col=rgb(1,0,0,0.2))\n```\n\n```{r prob, h=4,w=5,fig.cap=paste(\"A bar plot of the matching probability of the candidates. The vertex \", NBDS$labelsGxp[which.max(NBDS$P[length(NBDS$Sx)+1,])],\" in $G\\'_x$ has the highest probability so is nominated as $x\\'$.\")}\n# Determine x' amongst the candidates based on the matching probability from SGM\nSx <- NBDS$Sx\nx <- NBDS$labelsGxp[length(Sx)+1]\nx.ind <- which(NBDS$labelsGx==x)\nCxp <- match(NBDS$Cxp,NBDS$labelsGxp) \n\nif (NBDS$case==\"possible\") {\n    prob <- NBDS$P[x.ind,Cxp]\n    names(prob) <- NBDS$labelsGxp[Cxp]\n    x.prob <- prob[which.max(prob)]\n    vhatstar <- as.integer(names(x.prob))\n    rank.prob <- rank(-prob,ties.method = \"average\")\n    plot(as.integer(names(prob)), prob, type=\"h\",col=2, lwd=2)\n    rank.prob <- matrix(rank.prob,nrow=1); colnames(rank.prob) <- paste0(\"V\",names(prob))\n    kable(rank.prob,caption=\"Rank of matching probability for candidates\")\n}\n```\n```{r plotg,echo=FALSE,eval=FALSE,h=4,w=8,fig.cap=fn('Plot of G1 (left) and G2 (right). red: v\\\\*, pink: vhat\\\\*, cyan: seeds, white: candidates.')}\nop <- par(mfrow=c(1,2))\nV(g1)$color <- V(g2)$color <- \"white\"\nV(g1)$color[seed] <- V(g2)$color[seed] <- \"lightblue\"\nV(g1)$color[x] <- \"red\"\nV(g2)$color[as.integer(names(which.max(prob)))] <- \"pink\"\n#coords <- layout_(g1,with_lgl())\ncoords <- layout_(g1,as_star())\nplot(g1, layout=coords, vertex.size=25)\nplot(g2, layout=coords, vertex.size=25)\npar(op)\n```\n```{r plotg2,echo=FALSE, eval=FALSE,h=4,w=8,fig.cap=fn('Plot of $G$ (left) and $G\\'$ (right), where the vertices are colored by red: $x$, cyan: seeds $S_x$, `heat.colors`: candidates (the reddier the color is, the higher the rank of the candidate is). The center vertex is $S_x[1]$, its first neighbors are in the first ring, their first neighbors are in the next ring, and the rests are placed in the outmost ring.')}\nop <- par(mfrow=c(1,2))\nV(g1)$color <- V(g2)$color <- \"white\"\nV(g1)$color[seed] <- V(g2)$color[seed] <- \"lightblue\"\nV(g2)$color[NBDS$labelsGxp[candidate]] <- \"lightgreen\"\nV(g1)$color[1] <- \"red\"\nV(g2)$label.color <- \"blue\"\nV(g2)$label.color[as.integer(names(which.max(prob)))] <- \"red\"\n#coords <- layout_(g1,with_lgl())\ncoords1 <- plotlayout(g1)\ncoords2 <- plotlayout(g2,vhatstar)\nplot(g1, layout=coords1, vertex.size=25)\nplot(g2, layout=coords2, vertex.size=25)\npar(op)\n```\n```{r plotg3,echo=FALSE, eval=TRUE,h=4,w=8,fig.cap=fn('Plot of $G$ (left) and $G\\'$ (right), where the vertices are colored by red in $G$: $x$, cyan on both graphs: $S_x$, `heat.colors` in $G\\'$: candidates (the more red the color is, the higher the rank of the candidate is). In both graphs, the center vertex is one of the seeds in $S_x$, its first neighbors are in the first ring, their first neighbors are in the next ring, and the rest are placed in the outmost ring.')}\nV(g1)$color <- V(g2)$color <- \"white\"\nV(g1)$color[Sx] <- V(g2)$color[Sx] <- \"lightblue\"\ncand.col <- heat.colors(length(Cxp)+10)\ncand.col <- cand.col[-c(2:11)]\nV(g2)$color[NBDS$labelsGxp[Cxp]] <- cand.col[rank.prob]\nV(g1)$color[x] <- \"red\"\nV(g2)$label.color <- \"blue\"\n#V(g2)$label.color[as.integer(names(which.max(prob)))] <- \"red\"\n#coords <- layout_(g1,with_lgl())\ncoords1 <- plotlayout(g1,Sx[1])\ncoords2 <- plotlayout(g2,Sx[1])\nop <- par(mfrow=c(1,2),mar=c(1,1,1,1))\nplot(g1, layout=coords1, vertex.size=15)\nplot(g2, layout=coords2, vertex.size=15)\n#plot(g1, vertex.size=15)\n#plot(g2, vertex.size=15)\npar(op)\n```\n```{r graphjs,echo=FALSE,eval=FALSE}\nrequire(threejs)\n#g12 <- igraph2graphjs(g1)\n#g22 <- igraph2graphjs(g2)\ng12 <- igraph2graphjs(HSfbgraphcore)\ngraphjs(g12)\n```\n\n# Simulation\n\nWe repeat the above 1000 times by generating new graphs each time, as well as new $x$ and $S$.\n\nWe define the normalized rank of the VOI $x$ in $G'$ with respect to the size of the candidate list $C'_x$ as follows,\n\n$$normalized~rank = \\frac{rank(x') -1}{|C'_x|-1},$$\n\nso that values of 0, 0.5, and 1 imply that the VOI is first, half-way down, and last in the candidate list, respectively.\n\nNB: In the tables and plots below, \n\n* `s1` means the number of seeds for `SGM`, $s_x=1$ and so on. \n* `mean.ncand` means averaged number of candidates for each case.\n* `mean.nrank` means averaged normalized rank for each case.\n\n\n```{r load,echo=FALSE}\nload(\"~/Dropbox/SGM/nbdmaking/MC-RDPG-rho0.1-seed1-N1-new2.Rbin\"); MC1 <- MC\nload(\"~/Dropbox/SGM/nbdmaking/MC-RDPG-rho0.9-seed1-N1-new2.Rbin\"); MC9 <- MC\ncase1 <- (sapply(MC1,\"[\",1))\ncase9 <- (sapply(MC9,\"[\",1))\nseed1 <- paste0(\"s\",sapply(MC1,\"[\",2)); seed1[case1!=\"possible\"] <- \"s0\"\nseed9 <- paste0(\"s\",sapply(MC9,\"[\",2)); seed9[case9!=\"possible\"] <- \"s0\"\n#ncandidate1 <- paste0(\"c\",sprintf(\"%02d\",as.numeric(sapply(MC1,\"[\",3))))\n#ncandidate9 <- paste0(\"c\",sprintf(\"%02d\",as.numeric(sapply(MC9,\"[\",3))))\nncandidate1 <- as.numeric(sapply(MC1,\"[\",3))\nncandidate9 <- as.numeric(sapply(MC9,\"[\",3))\nrank.vstar1 <- as.numeric(sapply(MC1,\"[\",4))\nrank.vstar9 <- as.numeric(sapply(MC9,\"[\",4))\ndf1 <- data.frame(corr=\"0.1\",case=case1,seed=seed1,ncand=ncandidate1,rank=rank.vstar1)\ndf1 <- df1 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf9 <- data.frame(corr=\"0.9\",case=case9,seed=seed9,ncand=ncandidate9,rank=rank.vstar9)\ndf9 <- df9 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf19 <- rbind(df1,df9)\ndf191 <- subset(df19,case==\"possible\")\nkable(df1 %>% group_by(case,seed) %>% summarize(count=n(),mean.ncand=mean(ncand), mean.nrank=mean(norm.rank)),caption=\"A summary of the simulation for `corr=0.1`\")\nkable(df9 %>% group_by(case,seed) %>% summarize(count=n(),mean.ncand=mean(ncand), mean.nrank=mean(norm.rank,na.rm=TRUE)),caption=\"A summary of the simulation for `corr=0.9`\")\n```\n\n```{r possible, echo=FALSE, eval=FALSE}\n## How many times \"possible\" ?\ncat(\"corr=0.1\\n\"); table(df1$case)\ncat(\"corr=0.9\\n\"); table(df9$case)\n```\n\n```{r seeds, echo=FALSE, eval=FALSE}\n## Number of seeds?\ncat(\"corr=0.1\\n\"); table(df191 %>% filter(corr==0.1) %>% select(seed))\ncat(\"corr=0.9\\n\"); table(df191 %>% filter(corr==0.9) %>% select(seed))\n```\n\n## Number of candidates?\n```{r cand, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the number of candidates using $MC=1000$.')}\nggplot(df191,aes(x=ncand,fill=corr)) + scale_fill_brewer(palette=\"Set1\") +\n#       facet_grid(corr~.) +\n#       theme(legend.title=element_blank()) +\n       geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)\n```\n```{r ncand, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the number of candidates as a function of  the number of seeds.')}\nggplot(df191,aes(x=ncand,fill=corr)) + scale_fill_brewer(palette=\"Set1\") +\n       facet_wrap(~seed) +\n       geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)\n```\n\n## Rank of $x'$?\n\n```{r rank, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the normalized rank of $x\\'$ as a function of the number of seeds $s_x$.')}\n#cat(\"corr=0.1\\n\"); table(rank.vstar1)\n#sum(table(rank.vstar1))\n#cat(\"corr=0.9\\n\"); table(rank.vstar9)\n#sum(table(rank.vstar9))\n#qplot(rank.vstar, geom=\"bar\")\n\n#norm.rank1 <- (rank.vstar1 - 1) / (ncandidate1 - 1)\n#norm.rank9 <- (rank.vstar9 - 1) / (ncandidate9 - 1)\n#df192 <- df19 %>% mutate(norm.rank=(rank-1)/(ncand-1))\n#df191$ncand <- c(paste0(\"c\",sprintf(\"%02d\",as.numeric(sapply(MC1,\"[\",3)))),\n#                 paste0(\"c\",sprintf(\"%02d\",as.numeric(sapply(MC9,\"[\",3)))))\ndf191$ncand <- paste0(\"c\",sprintf(\"%02d\",df191$ncand))\ndf191 <- subset(df191,case==\"possible\")\n\nggplot(df191,aes(x=norm.rank,fill=corr)) + scale_fill_brewer(palette=\"Set1\") +\n        facet_wrap(~seed) +\n#        theme(legend.title=element_blank()) +\n        geom_histogram(binwidth=.05,position=\"identity\",alpha=0.5)#, aes(fill=..count..))\n```\n```{r Ex, echo=FALSE, eval=FALSE,w=7,h=5,fig.cap=fn('A histogram of the number of edges between $x\\'$ and $S\\'_x$.')}\nExp1 <- as.numeric(sapply(MC1,\"[\",6))\nExp9 <- as.numeric(sapply(MC9,\"[\",6))\ncat(\"corr=0.1\\n\"); table(Exp1)\nsum(table(Exp1))\ncat(\"corr=0.9\\n\"); table(Exp9)\nsum(table(Exp9))\n\ndf2 <- cbind(df192, ExSpx=c(Exp1,Exp9))\nggplot(subset(df2,seed!=\"s0\"),aes(x=ExSpx,fill=factor(corr))) + scale_fill_brewer(palette=\"Set1\") +\n        facet_wrap(~seed) +\n#        theme(legend.title=element_blank()) +\n        geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)#, aes(fill=..count..))\n```\n```{r Ex2, echo=FALSE, eval=FALSE,w=5,h=4,fig.cap=fn('Average number of edges between $x\\'$ and $S\\'_x$ as a function of number of seeds, $s_x$.')}\n#kable((dfmean <- df2 %>% group_by(corr,seed) %>% summarize(count=n(),mean.ExSpx=mean(ExSpx))),digits=2,caption = \"Average number of edges between $x'$ and $S'_x$ as a function of number of seeds, $s_x\")\ndfmean <- df2 %>% group_by(corr,seed) %>% summarize(count=n(),mean.ExSpx=mean(ExSpx))\nggplot(dfmean, aes(seed,mean.ExSpx,fill=factor(corr))) + scale_fill_brewer(palette=\"Set1\") +\n#        facet_wrap(~corr) + theme(legend.position=\"none\") +\n        geom_bar(stat=\"identity\",position=position_dodge(width=0),alpha=0.5)\n```\n```{r nx, echo=FALSE, eval=FALSE,w=5,h=4,fig.cap=fn('A histogram of the number of common neighbors of $x$ as a function of the number of seeds $s_x$.')}\nNx1 <- as.numeric(sapply(MC1,\"[\",5))\nNx9 <- as.numeric(sapply(MC9,\"[\",5))\ncat(\"corr=0.1\\n\"); table(Nx1)\nsum(table(Nx1))\ncat(\"corr=0.9\\n\"); table(Nx9)\nsum(table(Nx9))\n\ndf3 <- cbind(df192, nx=c(Nx1,Nx9))\nggplot(subset(df3,seed!=\"s0\"),aes(x=nx,fill=factor(corr))) + scale_fill_brewer(palette=\"Set1\") +\n        facet_wrap(~seed) +\n        geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)#, aes(fill=..count..))\n```\n```{r rank2, echo=FALSE, eval=TRUE,w=7,h=8,fig.cap=fn('A histogram of the normalized rank of $x\\'$ as a function of the number of candidates and the number of seeds.')}\nggplot(subset(df191,seed %in% c(\"s1\",\"s2\",\"s3\")),aes(x=norm.rank, fill=corr)) +\n        scale_fill_brewer(palette=\"Set1\") +\n        facet_grid(ncand~seed) +\n#        theme(legend.title=element_blank()) +\n#        facet_wrap(~seed+ncand,ncol=3) +\n        geom_histogram(binwidth=.05,position=\"identity\",alpha=0.5)#, aes(fill=..count..))\n```\n\n# Real Data\n\n> R. Mastrandrea, J. Fournet, and A. Barrat, _Contact patterns in a high school: a comparison between data collected using wearable sensors, contact diaries and friendship surveys_, PLoS ONE, 2015.\n\nWe look at two High School friendship networks on over-lapping vertex sets found in our draft. The first network consists of 134 vertices, each representing a particular student, in which two vertices are adjacent if one of the students reported or a survey that the two are friends. The second network, with 156 vertices, consists of a Facebook network of profiles in which two vertices are adjacent if they were friends on Facebook. There are 82 $core$ vertices across the two networks for which we know the bijection between the two vertex sets, and it is known that no such bijection exists among the remaining vertices.\n\n## Full Graphs\n\nFirst, we do the same experiment as above using the full graphs. We randomly select the VOI $x$ and seeds $S$ from the shared vertices (82 core vertices) and repeat for $MC=1000$ times. \nSince we are choosing the VOI and seeds to be in the core vertex sets, the VOI will exist in the second network; it just may not exist in $C_x'$ (the candidate set generated by the seeds) -- i.e. while the VOI $x$ is guaranteed to have a match $x'$, this vertex will not be found if it is not also in $C'_x$ (`impossible2`).\n\n```{r data, echo=FALSE}\ns <- 12\nload(paste0(\"~/Dropbox/SGM/nbdmaking/MC-new2-HS-full-s\",s,\".Rbin\"))\ncase2 <- (sapply(MC,\"[\",1))\nseed2 <- paste0(\"s\",sprintf(\"%02d\",as.numeric(sapply(MC,\"[\",2)))); seed2[case2!=\"possible\"] <- \"s0\"\nncandidate2 <- as.numeric(sapply(MC,\"[\",3))\nrank.vstar2 <- as.numeric(sapply(MC,\"[\",4))\ndf2 <- data.frame(case=case2,seed=seed2,ncand=ncandidate2,rank=rank.vstar2)\ndf2 <- df2 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf21 <- subset(df2,case==\"possible\")\nkable(df2 %>% group_by(case,seed) %>% summarize(count=n(),mean.ncand=mean(ncand), mean.nrank=mean(norm.rank,na.rm=TRUE)),caption=\"A summary statistics using the full graphs\")\n\n#plt <- 27\n```\n\n```{r possible2, echo=FALSE, eval=FALSE}\n### How many times \"possible\" ?\ntable(df2$case)\n```\n\n```{r seeds2, echo=FALSE, eval=FALSE}\n### Number of seeds?\ntable(df21$seed)\n```\n\n### Number of candidates?\n```{r cand2, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the number of candidates as a function of the number of seeds.')}\nggplot(df21,aes(x=ncand,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n#    theme(text=element_text(size=13)) + xlab(\"number of candidates\") +\n#       geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)\n#       geom_density(alpha=0.5,adjust=1)\n       facet_wrap(~seed) + #scale_fill_manual(\"s_x\") +\n       geom_histogram(binwidth=1,position=\"identity\",alpha=1)\n```\n\n### Rank of $x'$?\n\n```{r rank3, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the normalized rank of $x\\'$ as a function of the number of seeds $s_x$.')}\n#table(rank.vstar)\n#sum(table(rank.vstar))\n#norm.rank <- (rank.vstar2 - 1) / (ncandidate2 - 1)\n#df22 <- df2 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf2$ncand <- paste0(\"c\",sprintf(\"%02d\",df2$ncand))\ndf2 <- subset(df2,case==\"possible\")\n\nggplot(df2,aes(x=norm.rank,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n        facet_wrap(~seed) + #scale_fill_manual(\"s_x\") +\n        geom_histogram(binwidth=.05,position=\"identity\",alpha=1)#, aes(fill=..count..))\n```\n```{r rank4, echo=FALSE, eval=TRUE,w=7,h=8,fig.cap=fn('A histogram of the normalized rank of $x\\'$ as a function of the number of candidates and the number of seeds.')}\n#ggplot(subset(df2,seed%in%c(\"s1\",\"s2\",\"s3\")),aes(x=norm.rank,fill=seed)) +\nggplot(subset(df2,seed%in%c(\"s01\",\"s02\",\"s03\")),aes(x=norm.rank,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n        facet_grid(ncand~seed) + #scale_fill_manual(\"s_x\") +\n        geom_histogram(binwidth=.05,position=\"identity\",alpha=1)#, aes(fill=..count..))\n```\n\n\n## Core Graphs\n\nWe do the same experiment as above using only the core graphs. We randomly select the VOI $x$ and seeds $S$ from the shared vertices (82 core vertices) and repeat for $MC=1000$ times. \n\n\n```{r cdata, echo=FALSE}\nload(paste0(\"~/Dropbox/SGM/nbdmaking/MC-new-pval-HS-core-s\",s,\".Rbin\"))\ncase3 <- (sapply(MC,\"[\",1))\nseed3 <- paste0(\"s\",sapply(MC,\"[\",2)); seed3[case3!=\"possible\"] <- \"s0\"\nncandidate3 <- as.numeric(sapply(MC,\"[\",3))\nrank.vstar3 <- as.numeric(sapply(MC,\"[\",4))\ndf2 <- data.frame(case=case3,seed=seed3,ncand=ncandidate3,rank=rank.vstar3)\ndf2 <- df2 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf21 <- subset(df2,case==\"possible\")\n#kable(df2 %>% group_by(case,seed) %>% summarize(count=n(),mean.ncand=mean(ncand), mean.nrank=mean(norm.rank,na.rm=TRUE)),caption=\"A summary statistics using the core graphs\")\n\npval <- as.numeric(sapply(MC,\"[\",5))\ndf3 <- data.frame(case=case3,seed=seed3,ncand=ncandidate3,rank=rank.vstar3,pval=pval)\ndf3 <- df3 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf31 <- df3 %>% group_by(case,seed) %>% summarize(count=n(),mean.ncand=mean(ncand), mean.nrank=mean(norm.rank,na.rm=TRUE),\"#pvals<0.05\"=sum(pval<0.05,na.rm=TRUE))\n\ndf31 <- df3 %>% group_by(case,seed) %>% summarize(count=n(),mean.ncand=mean(ncand), mean.nrank=mean(norm.rank,na.rm=TRUE),\"#pvals<0.05\"=sum(pval<0.05,na.rm=TRUE),\"mean(nrank[pval<0.05])\"=mean(norm.rank[pval<0.05],na.rm=TRUE))\nkable(df31, caption=\"A summary statistics using the core graphs\")\n```\n\n```{r pval, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A density of the p-values as a function of the number of seeds.')}\ndf32 <- df3 %>% filter(case==\"possible\")\n\np32 <- ggplot(df32,aes(x=pval,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n#    theme(text=element_text(size=13)) + \n    xlab(\"p-values\") + xlim(NA,1) +\n#       geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)\n       facet_wrap(~seed) #+ #scale_fill_manual(\"s_x\") +\n#p32 + geom_density(alpha=1,adjust=1)\n#p32 + stat_density(alpha=1,adjust=1)\n#p32 + geom_freqpoly(alpha=1)\np32 + geom_histogram(binwidth=.05,position=\"identity\",alpha=1)\n```\n\n```{r cpossible2, echo=FALSE, eval=FALSE}\n### How many times \"possible\" ?\ntable(df2$case)\n```\n\n```{r cseeds2, echo=FALSE, eval=FALSE}\n### Number of seeds?\ntable(df21$seed)\n```\n\n### Number of candidates?\n```{r ccand2, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the number of candidates as a function of the number of seeds.')}\nggplot(df21,aes(x=ncand,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n#    theme(text=element_text(size=13)) + \n    xlab(\"number of candidates\") +\n#       geom_histogram(binwidth=1,position=\"identity\",alpha=0.5)\n#       geom_density(alpha=0.5,adjust=1)\n       facet_wrap(~seed) + #scale_fill_manual(\"s_x\") +\n       geom_histogram(binwidth=1,position=\"identity\",alpha=1)\n```\n\n### Rank of $x'$?\n\n```{r crank3, echo=FALSE, eval=TRUE,h=4,fig.cap=fn('A histogram of the normalized rank of $x\\'$ as a function of the number of seeds $s_x$.')}\n#table(rank.vstar)\n#sum(table(rank.vstar))\n#df22 <- df2 %>% mutate(norm.rank=(rank-1)/(ncand-1))\ndf21$ncand <- paste0(\"c\",sprintf(\"%02d\",df21$ncand))\ndf21 <- subset(df21,case==\"possible\")\n\nggplot(df21,aes(x=norm.rank,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n        facet_wrap(~seed) + #scale_fill_manual(\"s_x\") +\n        geom_histogram(binwidth=.05,position=\"identity\",alpha=1)#, aes(fill=..count..))\n```\n```{r crank4, echo=FALSE, eval=TRUE,w=7,h=8,fig.cap=fn('A histogram of the normalized rank of $x\\'$ as a function of the number of candidates and the number of seeds.')}\nggplot(subset(df21,seed%in%c(\"s1\",\"s2\",\"s3\")),aes(x=norm.rank,fill=seed)) + scale_fill_brewer(name=\"s_x\",palette=\"Set1\") +\n        facet_grid(ncand~seed) + #scale_fill_manual(\"s_x\") +\n        geom_histogram(binwidth=.05,position=\"identity\",alpha=1)#, aes(fill=..count..))\n```\n\n# `R` Package\n\nThe latest `R` source package can be downloaded from [here](http://www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.3.0.tar.gz).  \nIt can be installed via:\n```{r echo=TRUE,eval=FALSE}\ninstall.packages(\"http://username:password@www.cis.jhu.edu/~parky/XDATA/SGM/VN_0.3.0.tar.gz\",type=\"source\",method=\"wget\")\n```\n```{r vn,echo=TRUE}\nlibrary(help='VN')\n```\n\n",
    "created" : 1479476167592.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "450|117|463|0|\n464|147|470|0|\n471|152|483|0|\n",
    "hash" : "2558551360",
    "id" : "F77889F3",
    "lastKnownWriteTime" : 1499705654,
    "last_content_update" : 1499708888153,
    "path" : "~/Dropbox/SGM/nbdmaking/vn.Rmd",
    "project_path" : null,
    "properties" : {
        "chunk_output_type" : "console",
        "docOutlineVisible" : "1",
        "last_setup_crc32" : ""
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}